#!/usr/bin/env python
from dynamic_reconfigure.parameter_generator_catkin import *
gen = ParameterGenerator()
Passing = gen.add_group("Passing")
Passing.add("static_field_position_quality_x_offset", double_t, 0, "The offset from the sides of the field to place the rectangular sigmoid we use to determine what areas to pass to", 0.3, 0, 1, edit_method="")
Passing.add("static_field_position_quality_y_offset", double_t, 0, "The offset from the sides of the field to place the rectangular sigmoid we use to determine what areas to pass to", 0.3, 0, 1, edit_method="")
Passing.add("static_field_position_quality_friendly_goal_distance_weight", double_t, 0, "The weight that being close to the goal will have on the static position quality. Lower, more negative weights result in the distance to the goal having less of an effect.", 0.3, 0, 1, edit_method="")
Passing.add("enemy_proximity_importance", double_t, 0, "This controls how heavily we weight a robot being near the pass receiver when calculating enemy risk to a pass", 0.5, 0, 10, edit_method="")
Passing.add("ideal_min_shoot_angle_degrees", double_t, 0, "The minimum open angle formed by the two enemy goal posts and the pass reception position that we think will likely result in a good shooting opportunity. Note that we may take shots below this in some cases, it's more of a weight then a cutoff.", 40, -360, 360, edit_method="")
Passing.add("ideal_max_rotation_to_shoot_degrees", double_t, 0, "The maximum angle that we have to rotate after receiving a pass to shoot that we think would likely result in a goal. Note that we may try to take shots that require us to rotate more then this, it's more of a soft limit.", 60, 0, 180, edit_method="")
Passing.add("min_pass_speed_m_per_s", double_t, 0, "The minimum pass speed (in m/s)", 2.0, 0, 5, edit_method="")
Passing.add("max_pass_speed_m_per_s", double_t, 0, "The maximum pass speed (in m/s)", 5.0, 0, 10, edit_method="")
Passing.add("min_time_offset_for_pass_seconds", double_t, 0, "Minimum time into the future at which the pass should occur. This is to ensure we have enough time to setup a robot to actually perform the pass. This is in seconds.", 0.7, 0, 5, edit_method="")
Passing.add("max_time_offset_for_pass_seconds", double_t, 0, "Maximum time into the future at which the pass should occur. This gives the upper bound on the pass start time, relative to the current time. This is in seconds.", 4.0, 0, 5, edit_method="")
Passing.add("enemy_reaction_time", double_t, 0, "How long we think the enemy will take to recognize we're passing and start moving to intercept", 0.4, 0, 3.0, edit_method="")
Passing.add("num_passes_to_optimize", int_t, 0, "The number of passes to try to optimize at any given time", 15, 1, 1000, edit_method="")
Passing.add("num_passes_to_keep_after_pruning", int_t, 0, "The number of passes to keep after pruning", 3, 0, 1000, edit_method="")
Passing.add("number_of_gradient_descent_steps_per_iter", int_t, 0, "The number of steps of gradient descent to perform in each iteration", 10, 0, 1000, edit_method="")
Passing.add("pass_equality_max_position_difference_meters", double_t, 0, "The maximum allowed difference between the reciever and passer point of two passes for which they are considered equal", 0.05, 0, 4, edit_method="")
Passing.add("pass_equality_max_start_time_difference_seconds", double_t, 0, "TODO: Add description as part of #149", 0.1, 0, 3, edit_method="")
Passing.add("pass_equality_max_speed_difference_meters_per_second", double_t, 0, "TODO: Add description as part of #149", 0.3, 0, 4, edit_method="")
Navigator = gen.add_group("Navigator")
Navigator.add("default_avoid_dist", double_t, 0, "TODO: Add description as part of #149", 50, 0, 100, edit_method="")
Navigator.add("collision_avoid_velocity_scale", double_t, 0, "TODO: Add description as part of #149", 0.5, 0, 1, edit_method="")
gen.add("robot_expiry_buffer_milliseconds", int_t, 0, "TODO: Add description as part of #149", 50, 0, 100, edit_method="")
Evaluation = gen.add_group("Evaluation")
Indirect_Chip = Evaluation.add_group("Indirect_Chip")
Indirect_Chip.add("chip_target_fraction", double_t, 0, "Adjusts how far between ball and target the robot will chip", 5.0/10.0, 0.0, 100.0, edit_method="")
Indirect_Chip.add("chip_power_bounce_threshold", double_t, 0, "Maximum fraction of distance between chipper and target the first bounce should be, so ball is rolling when it reaches the target", 7.5/10.0, 0.0, 5.0, edit_method="")
Indirect_Chip.add("max_chip_power", double_t, 0, "Maximum power the robot can chip the ball at without malfunctions", 8.0, 0.0, 100.0, edit_method="")
Indirect_Chip.add("chip_target_area_inset", double_t, 0, "Closest distance to edge of field that the robot could chip and chase to", 0.3, 0.0, 100.0, edit_method="")
Indirect_Chip.add("min_chip_tri_area", double_t, 0, "Minimum area of chip target triangle", 0.5, 0.0, 100.0, edit_method="")
Indirect_Chip.add("min_chip_tri_edge_len", double_t, 0, "Minimum edge length of chip target triangle", 0.8, 0.0, 100.0, edit_method="")
Indirect_Chip.add("min_chip_tri_edge_angle", double_t, 0, "Minimum angle in degrees between chip triangle edges", 20, 0.0, 180.0, edit_method="")
Indirect_Chip.add("chip_cherry_power_downscale", double_t, 0, "Percentage of distance to center of triangle to return as target", 0.85, 0.0, 100.0, edit_method="")
DefenseShadowEnemyTactic = gen.add_group("DefenseShadowEnemyTactic")
DefenseShadowEnemyTactic.add("ball_steal_speed", double_t, 0, "Try to steal the passee's ball below this ball speed", 0.3, 0.0, 1.0, edit_method="")
DefenderCreaseTactic = gen.add_group("DefenderCreaseTactic")
DefenderCreaseTactic.add("max_defender_seperation_deg", double_t, 0, "The maximum angle the crease defenders will seperate by, in degrees.", 13.0, 0.0, 50, edit_method="")
DefenderCreaseTactic.add("min_defender_seperation_deg", double_t, 0, "The minimum angle the crease defenders will seperate by, in degrees.", 3.0, 0.0, 50, edit_method="")
DefenderCreaseTactic.add("ball_dist_for_max_defender_seperation", double_t, 0, "The distance between the ball and the defenders at which they will have their maximum seperation.", 3, 0.0, 5, edit_method="")
DefenderCreaseTactic.add("ball_dist_for_min_defender_seperation", double_t, 0, "The distance between the ball and the defenders at which they will have their minimum seperation.", 1, 0.0, 5, edit_method="")
GoalieTactic = gen.add_group("GoalieTactic")
GoalieTactic.add("block_cone_buffer", double_t, 0, "The block cone buffer is the extra distance to add on either side of the robot to allow to it be further back in the block cone", 0.0, 0.0, 2.0, edit_method="")
PivotAction = gen.add_group("PivotAction")
PivotAction.add("arb_scaling", double_t, 0, "How quickly to pivot", 1.0, 0.0, 10.0, edit_method="")
PivotAction.add("finish_angle_threshold", double_t, 0, "How much tolerance in degrees we allow for the final angle before annoucing pivot has finished", 5.0, 0.0, 360.0, edit_method="")
RobotCapabilities = gen.add_group("RobotCapabilities")
RobotCapabilities.add("broken_dribblers", str_t, 0, "Comma-separated list of numbers of robots with broken dribblers", "", None, None, edit_method="")
RobotCapabilities.add("broken_chippers", str_t, 0, "Comma-separated list of numbers of robots with broken chippers", "", None, None, edit_method="")
RobotCapabilities.add("broken_kickers", str_t, 0, "Comma-separated list of numbers of robots with broken kickers", "", None, None, edit_method="")
exit(gen.generate("param_server", "ps", "ai"))